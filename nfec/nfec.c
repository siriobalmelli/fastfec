/*
	NFEC	-	n-dimension FEC

PURPOSE
All digital transmission or storage systems have some degree of error.
FEC (Forward Error Correction) is a technique for generating some amount of
	extra "repair" data at a TX(source), which can be used to recover
	losses in transit to a RX(destination).
This is useful where the time/bandwidth cost of re-transmitting lost data
	is higher than the cost of adding a small, constant "repair" overhead
	to the signal; then using that overhead to recover for losses on-the-fly
	without asking for retransmission.

SYMBOLS
In this system, data is handled in constant-sized blocks termed "symbols".
The symbol size is decided at instantiation and must be the same at TX and RX.
If symbols are too big, loss of some portion of the symbol invalidates
	the whole symbol (thus increasing the amount of actual data lost).
If symbols are too small, computation costs rise.
As a rule of thumb, symbol size should be the packet size of a link;
	e.g.: the payload size of one Ethernet frame.
Symbols are split into:
	"source"	:	the data we wish to transmit and recover
	"repair"	:	extra data generated and transmitted to permit recovery

EQUATIONS
Symbols are combined into equations, using the binary operator XOR (aka: `^`).
XOR has some interesting properties:
-	It's quite fast
-	It's bitwise (has no carry, fixed-size operands)
-	Order of operations doesn't matter (it's commutative):
		`a ^ b = b ^ a`	
-	It yields 0:
		`a ^ b = c`
		`a ^ b ^ c = 0`
In the equation above, 'a' and 'b' are source symbols, while 'c' is a
	repair symbol generated by XORing 'a' with 'b'.
It is now possible to recover any one lost symbol by XORing the others:
	`a ^ b = c`
	`a ^ c = b`
	`b ^ c = a`

This is not limited to 3 factors: any number of symbols may be in an equation
	and as long as only one symbol is missing,
	it can be recovered by XORing the others.

BLOCKS
Data to be error corrected needs to be processed in blocks.
The source symbols in a block XOR together with other symbols in that block
	to produce repair symbols.
All symbols are then sent, and missing symbols are computed at the destination
	if possible.
A block contains 'n' symbols, 'k' of which are source and 'p' of which are repair.
The "p" in this context is "parity" but the author prefers the term "repair"
	which is synonymous.

MATRIX
Symbols can be members of multiple equations.
A perfect FEC scheme would generate 'p' repair symbols and be able to tolerate
	the loss of any combination of `n - p` symbols.
Conceptually, this involves representing all possible symbol combinations as equations
	(not exactly, but just go with it),
	which is computationally infeasible.
The solution used here is to represent the block as a matrix,
	where the columns are symbols and the rows are equations.
A '1' in the matrix assigns a symbol to an equation.
The approach used here to distribute 1's most effectively is called
	LDGM (Low Density Generator Matrix),
	and it uses a random sequence to most evenly spread
	a small amount (low density) of 1's across the matrix.
The symbols are then sent in random order, to spread symbol losses
	most evenly across the columns of the matrix.

INEFFICIENCY
We cannot recover ANY combination of `n - p` lost symbols:
	there is some inneficiency in the system.
This inefficiency is expressed as a fractional number >1,
	so that `(n - p) / inefficiency` is the number of
	packet losses we can actually recover from.

BLOCK SIZE vs LATENCY
The size of blocks is important TODO

N DIMENSIONS
This is an "n-dimensional" 


------------------------ sample matrix ---------------------------------------------------------
"page"								// group/range of source or repair symbols

width		:	2					// nr. of pages in a matrix, overlap "depth"
page_cnt	:	>= (width * 2 -1)			// The more pages, the more trailing "inactive"
								//	regions which can be used as a re-request buffer.

N		:	1					// Row-count per column.
								// NOTE: "1" in unrealistic but simple to portray.
cell_cnt	:	N * width		:	2	// how many matrix cells per source symbol


page_cnt == width * 2 - 1 (the minimum)
	s0-3 | s4-7 | s8-11		p0-2 | p3-5 | p6-8
r0-2	x	x			x
r3-5		x	x			x
r6-8	x		x				x

page_cnt == 6 (arbitrarily more pages)
	s0-3 | s4-7 | s8-11 | s12-15 | s16-19 | s20-23		p0-2 | p3-5 | p6-8 | p9-11 | p12-14 | p15-17
r0-2	x	x						x
r3-5		x	x						x
r6-8			x	x						x
r9-11				x	x						x
r12-14					x	x						x
r15-17	x					x							x

NOTES:
-	'x' means that range/page of colums/symbols randomly distributed across that range/page of rows/equations
-	Notice that there are 'width' x's for each page
------------------------ repeats identically --------------------------------------------------


THOUGHTS: 
-	Page states:
		current	:	page belonging to latest symbol received/encoded
		active	:	"moving window" of pages centered on the current page; 
					+/- (width-1) in both directions.
		stale	:	non-active pages

	The page belonging to the latest symbol received/encoded
-	'seq_no' should probably be stored in each row?
		no; probably the "cycle count" : `seq_no / (src_page * page_cnt)`
-	UINT32_MAX should divide into `src_page * page_cnt` evenly,
		so overflow doesn't explode things.
-	DO we need to distinguish between "solved" and "unused" states of a cell?
	For now, ASSUME we don't.
-	Randomize matrix "1" allocation only once.
-	Algo for staircase-assigning rows to each cell (before KFY random):
		Ps1	-> Pr0, Pr1		// PAGEsource1	-> PAGErepair0, PAGErepair1
		Ps2	-> Pr1, Pr2
		Ps3/0	-> Pr2, Pr3/0
-	Algo for recursion: single matrix "row" of cell IDs pending decode?
	This way NO MALLOC; and the same cell_id may be "set" (added to the row) more than once
		when decoding recursively without ill consequences.
-	When working with a seq_no; only invalidate FORWARD (looping with modulo if necessary)
-	'sym_id' MSb is 'src/repair' ?


------------------------ another sample matrix ------------------------------------------------
source/page	:	10
parity/page	:	4

width		:	4
page_cnt	:	width * 2 -1		:	7

num_source	:	page_cnt * source_page	:	70
num_parity	:	page_cnt * parity_page	:	28

N		:	1					// fake, for simplicity's sake only
cell_cnt	:	N * width		:	4

	source symbols						repair symbols
	s0-9 | 10-19 | 20-29 | 30-39 | 40-49 | 50-59 | 60-69	p0-3 | 4-7 | 8-11 | 12-15 | 16-19 | 20-23 | 24-27
	[ ---- preseed ---- ]
r0-3	x	x	x	x				x
r4-7		x	x	x	x				x
r8-11			x	x	x	x				x
r12-15				x	x	x	x				x
r16-19	x				x	x	x					x
r20-23	x	x				x	x						x
r24-27	x	x	x				x							x
------------------------ repeats identically --------------------------------------------------

*/


#include <stdint.h>
#include <pcg_rand.h>

/*	nfec_params
Directionless parameters; must match at TX and RX for proper reconstruction.
*/
struct nfec_params {
	/* classic FEC params FOR EACH PAGE */
	double		ratio;
	uint32_t	sym_len;

	uint32_t	N;			/* Number of matrix 1's per symbol */

	/* page-related params */
	uint32_t	width;			/* nr. pages in a single matrix; overlap depth */
	uint32_t	pad_32;

	/* random seed */
	struct pcg_state	rng;
}__attribute__((packed));



#include <ffec_matrix.h>

/*	nfec_page_state
Internal state counters for each page
*/
struct nfec_page_state {
	uint32_t		k_remain;	/* How many source symbols left to encode/decode? */
	uint32_t		k_in_use;	/* Number of symbols still referenced by caller;
							avoid overwriting memory still in use.
						*/
}__attribute__((packed));

/*	nfec_direction
*/
enum nfec_direction {
	nfec_encode,
	nfec_decode
};


/*	nfec_instance
Opaque struct for caller to pass to nfec
*/
struct nfec_instance {
	/* params */
	struct nfec_params	*par;
	enum nfec_direction	dir;

	/* per-page symbol counts */
	uint32_t		k;
	uint32_t		p;
	uint32_t		n;

	/* Memory
	Single alloc/mmap @source; all other pointers are for convenience.
	*/
		/* Symbols */
	void			*source;
	void			*parity;
	void			*psums;
		/* Matrices */
	struct ffec_cell	*cells;
	struct ffec_row		*rows;
	struct ffec_row		*dec_stack;	/* Instead of using Judy as a decode recursion stack */

	/* State */
	uint64_t		seq_no;		/* Monotonic symbol (not page) sequence */
	struct nfec_page_state	*state;
};


/*	nfec_seed()
Sanity-check user provided params.

Returns a newly allocated nfec_params; NULL on error.
Caller must free() returned struct when finished.
*/
struct nfec_params	*nfec_seed(	double ratio, uint32_t sym_len,
					uint32_t N,
					uint32_t width,
					uint64_t seed1, uint64_t seed2);


/*	nfec_new()
Allocate and return a new nfec_instance, AND the buffer memory it uses for symbols.

NOTE:	'par' is handled by caller, and MUST remain valid (not free()d) for
		the lifetime of the nfec_instance.

Caller must call nfec_free() on returned structure when finished.
*/
struct nfec_instance	*nfec_new(struct nfec_params *par, enum nfec_direction dir);
void			nfec_free(struct nfec_instance *ni);


/*	nfec_symbol
Communicate and track symbols from/to caller.
Allows caller to use  { 'seq_no'; 'sym_id' } as their unique ID for the packet.
Suitable as a format over-the-wire (replace 'symbol' with the actual symbol data).
*/
struct nfec_symbol {
	uint64_t	seq_no;
	uint32_t	sym_id;
	uint32_t	fnv1a;		/* fnv1a of symbol; seq_no; sym_id
					Allows direct use as protocol over IP,
						e.g.: with ID 0x44 (Dist. File System)
					*/
	void		*symbol;
}__attribute__((packed));


/*	nfec_enc()
copy/splice; then encode <= 'in_len' Bytes from 'in_mem'.

Writes encoded symbols to 'out_syms' (which must be allocated by caller and be of sufficient size);
	sets '*out_len' to number of symbols written.

Returns Bytes encoded, which MAY BE < 'in_len' if insufficient buffer space available.
Caller must free buffer space using nfec_sym_done().

Any data in 'in_mem' successfully encoded can be free()d or overwritten by caller.
*/
size_t			nfec_enc(struct nfec_instance	*ni,
				const void		*in_mem,
				size_t			in_len,
				struct nfec_symbol	*out_syms,
				size_t			*out_cnt);

/*	nfec_sym_done()
Inform nfec that one or more symbols are no longer in use by caller,
	and the underlying memory can be recycled.
*/
void			nfec_sym_done(struct nfec_instance	*ni,
					struct nfec_symbol	*syms,
					size_t			sym_cnt);

/*	nfec_dec()
???
*/
